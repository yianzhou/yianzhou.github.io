# 比特币

## 基础知识

比特币价格从 2010 年“1 万枚买两个披萨”涨至如今的数万美元。

2008 年中本聪发布白皮书，2009 年发布比特币钱包软件。

比特币软件只是普通的电脑程序，运行后连接“种子节点”（Seed Nodes，如中本聪的 IP）。节点间相互分享 IP 并建立连接，形成去中心化的 P2P（点对点）网络。[种子节点](https://github.com/bitcoin/bitcoin/blob/master/contrib/seeds/nodes_main.txt)

私钥本质上就是一个 256 位的随机整数，用十六进制表示。随机生成私钥后，使用椭圆曲线加密算法生成公钥，具体的曲线标准是 secp256k1。

把公钥做一次 SHA-256 哈希，对结果再做一次 RIPEMD-160 哈希，得到了一个 160 位（20 字节）的“公钥哈希”。在尾部加上 4 个字节的 Checksum。最后使用 Bech32 编码，得到钱包地址。

去中心化记账：没有中央账本，每个人都负责记账。电脑内存中开辟空间（内存池）存放临时交易记录。为了去中心化，比特币要求任何一台普通电脑（甚至树莓派）都能运行全节点，下载并验证所有账本数据。

Coinbase 铸币交易：**每个**区块的第一笔交易通常是凭空发给矿工的奖励（最初是 50 BTC，每 4 年减半）。经历了 2012、2016、2020、2024 年的减半，目前的奖励是 3.125 BTC。

区块头 (Block Header) 的关键要素：

- 交易哈希树：将区块内所有交易进行哈希运算得到的数值
- 上一区块哈希：链接前一个区块，形成链条
- 时间戳：当前时间
- 难度目标 (Bits)：规定哈希值必须小于的数值
- 随机数 (Nonce)：用于挖矿碰撞的数字

比特币区块头里有一个标准的“随机数（Nonce）”字段，只有 32 位（约 42 亿种可能）。现在的矿机算力太强了，42 亿个数字瞬间就能试完，通常试完了也找不到符合难度的哈希值。矿工必须改变区块里的其他数据来重置哈希计算。最方便修改的地方就是 Coinbase Data。中本聪在比特币的第 0 号区块（Genesis Block）的 Coinbase Data 里写下了一句永恒的留言：

> "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"

挖矿的本质是不断修改区块头中的随机数和 Coinbase Data，进行 SHA256 哈希运算，直到算出的哈希值小于网络规定的目标值。一旦算出符合要求的哈希，广播给全网，其他节点验证通过后存入本地数据库。

设计目标是平均每 10 分钟出一个区块。每 2016 个区块（约 2 周）检查一次，若太快则增加难度（目标值变小，前缀 0 变多），太慢则降低难度。这是为了让新产生的区块有足够的时间传播到全球每一个角落，减少分叉的概率，确保全网达成共识。

最长链原则：全网只承认最长的那条链。

流程：当第一个区块产生后，所有矿工立即引用该区块哈希，开始挖第二个区块。谁先算出，谁就赢得记账权和奖励。

比特币没有“余额”概念，只有未花费的交易输出 (UTXO)。

在比特币网络里，花费 = 销毁旧的 UTXO（标记为 Spent），接收 = 生成新的 UTXO（标记为 Unspent）。

例子：你有 50 BTC，要转给别人 9 BTC。你需要把 50 BTC 全部花掉：9 BTC 给对方，40 BTC 转回给自己，剩余 1 BTC 作为手续费。

你的比特币钱包里显示的“余额：5.5 BTC”，其实是钱包软件帮你算出来的。实际上，这 5.5 个币可能分散在无数个不同的旧交易里。

手续费：给矿工的打包费。手续费越高，交易在内存池中越优先被打包。

确认状态：交易广播后先进入内存池（未确认），被矿工打包进区块后才算“确认”交易。

比特币节点通过配置文件中的 `maxmempool` 参数来控制内存池大小。默认值 300 MB。每个节点运营者都可以自己修改这个值。如果你是大型矿池或区块浏览器，为了捕获尽可能多的交易，你可能会把它设为 1 GB 甚至更大。

当待确认交易的总积压量达到 300 MB 时，节点不会崩溃，也不会停止接收交易，而是启动末位淘汰机制：

- 提高门槛节点会设定一个最低费率标准（例如：必须大于 5 sats/vByte 才能进我的池子）。
- 驱逐低费率交易：池子里那些手续费率最低的交易会被踢出内存池，给高费率的新交易腾位置。

如果你发的交易手续费太低，且内存池满了，你的交易会被节点直接丢弃，就像你从未发送过一样。

除了空间限制，还有时间限制。默认的 `mempoolExpiry`（过期时间）是 336 小时（即 2 周）。如果一条交易在内存池里呆了 2 周还没被矿工打包（通常是因为手续费给得太少，没人愿意理它），它也会被自动踢出内存池。

如果全球 80 亿人都要用比特币主网去买咖啡，网络会瞬间瘫痪，手续费会飙升到几百美元一杯咖啡，而且你还得站在柜台前等 10 分钟确认。把高频的小额交易挪到链下处理，类似 VISA 或支付宝，这些交易不上链，只是双方记账并更新余额签名。只有当他们决定不玩了，才把最终余额写回到比特币主网。类似央行清算系统或国际黄金运输。

比特币主网的处理速度（TPS）只有 7 笔/秒，这是基于 1MB 的区块大小限制和 250 字节平均交易大小算出来的经典基准线（出块时间 10 分钟，一个区块最多容纳 4000 笔交易）。

在比特币的每个区块中，交易记录被组织成了一棵“二叉哈希树”。叶子节点——每一笔交易的哈希值（TxID），都在树的底部。相邻的两个交易哈希值两两配对，进行哈希运算，生成上一层的父哈希。这个过程一直向上重复。最后剩下的那个唯一的哈希值，就是树根。这个根哈希被记录在比特币的区块头中。默克尔树路径（Merkle Path）是从要验证的交易的位置开始，沿着树向上爬升计算出树根所需的所有“邻居”哈希值。它的作用是在不下载整个数据库（区块）的情况下，快速证明某笔特定的交易真实存在于这个区块中。

## 安全性

比特币的账本之所以无法被篡改，是因为**篡改的代价远远高于篡改所能获得的收益**。

如果仅仅是重算哈希值，现代计算机一秒钟能算几十亿次，似乎不难。但比特币引入了挖矿机制，让重算变得极其昂贵。

挖矿不是简单的计算，而是要找到一个小于特定目标值的哈希。这是一个纯概率的“掷骰子”过程。

比特币网络中的所有节点只承认最长的那条链。攻击者如果要篡改以前的区块，他不仅要重新计算那个区块的哈希，还必须重新完成从那个区块到现在所有区块的挖矿工作量。

目前全网算力高达 900 EH/s（即每秒 900 亿亿次哈希计算）。这意味着，要重写历史，你需要消耗通过燃烧天量电力产生的巨大算力。

51% 算力攻击：假设你想篡改账本，你自己偷偷挖了一条“假链”。与此同时，全网其他诚实的矿工（占绝大多数算力）正在现有的“真链”上继续拼命挖新的区块。因为你的算力比全网总和低，你挖矿的速度一定比大部队慢。你的“假链”永远追不上“真链”的长度。当你把假链广播出去时，会被所有节点当作“短链”直接丢弃。除非你能掌控全网 51%以上 的算力，你才能比全网其他人挖得快，从而让你的“假链”成为最长链。但在现实中，要获得超过全网 900 EH/s 的算力，需要数百亿美元的硬件投入和国家级的电力支持，在经济上几乎是不可能的。

## 双花攻击

假设黑客 Alice 想用 双花攻击 (Double Spend) 骗走你的一辆法拉利：

- 交钱：Alice 转账给你的地址（买车），被矿工打包了，这笔交易被记录在了链上最新一个区块。
- 发货：你看到钱到账了，把车钥匙给了 Alice。
- 攻击：Alice 其实偷偷在私下里用更强的算力挖了一条更长的链。在那条私链里，她把那笔钱转给了自己。
- 回滚：Alice 此时公布她的私链。根据“最长链原则”，全网节点会抛弃原来的链（包含给你钱的那条），接受 Alice 的新链。

随着时间的推移，推翻这笔交易所需的成本将呈指数级上升，直到高到任何理性的黑客都无法承担。中本聪在白皮书里通过泊松分布（Poisson Distribution）计算过这个概率。如果黑客有 10% 的算力（这已经非常恐怖了，相当于几个大型矿池的总和）：

- 等待 1 个确认：攻击成功率约 20%。
- 等待 2 个确认：攻击成功率约 5%。
- 等待 6 个确认：攻击成功率降至 0.024%。

结论：当交易经过 6 个区块（约 60 分钟）的埋藏后，即使黑客拥有全网 10% 的算力，他也几乎不可能追上并覆盖掉这 6 个区块的工作量，电费和硬件磨损成本会远大于这笔交易本身的价值。

- 买咖啡：0 确认 其实就够了（没人会花几百万美元电费去骗你一杯咖啡）。
- 一般转账：1-3 个确认 就非常安全了。
- 大额交易（交易所充值/买房）：6 个确认是行业标准。因为对于几千万美元的转账，黑客理论上可能愿意挺而走险，但 6 个确认让这个风险高到不划算。
